"""
Author: Justin Baik
Date created: 11/28/2017
Title: run_experiment with GUI control
Notes:

This is a GUI program used to do the following:
- keeps track of mice information (one system can run upto 4 mice at the same time). The GUI defines how many mice are run and creates ID for each mouse.
- start and stop EEG and EMG recording (using intan RHD2000) with user defined inputs. User can set the duration of the experiment and also set
the delay to start after a certain time.
- runs on different modes: open loop and closed loop. Open loop mode sends signals to either Arduino or RPi to trigger the laser. Closed loop mode
works only with the raspberry pi using socket communication. Because pi is prone to C related crashes, only using arduino for now (on open loop). 
- creates and move info txt file that is unique to the experiment with the user input settings. This txt later gets used to post-process the raw data.
- real-time spectral analysis of the EEG signal by reading off from the raw data that gets updated upon the start of an experiment. This spectral
data gets plotted on a second window.


This program is sort of a wrapper for the DAQ software that came with the Intan system. This program talks to the DAQ board via arduino or pi by sending
serial commands. The DAQ board has a trigger input that starts recording when it has a high input and stops when the signal shuts down. The DAQ software
also has a GUI to display the input signals from amplifiers / digital inputs / analog inputs. Right now, I am only using the amplifier signals for the
EEG and EMG, and the digital inputs for getting the camera strobe signals, laser trigger signals, the onoff signal that triggers DAQ recording.
"""

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QObject, QThread, pyqtSignal, pyqtSlot, QTimer
from PyQt5.QtWidgets import QFileDialog, QInputDialog, QLineEdit, QMessageBox
import pyqtgraph as pg
from run_GUI_v9 import Ui_MainWindow
import socket
import numpy as np
import scipy
import scipy.signal
import PyCapture2
import cv2
import serial
import serial.tools.list_ports as com_read
import time
import sys
import shutil
import os
import glob
import pdb

######## functions used for the real time spectral analysis of EEG/EMG signals ########

def power_spectrum(data, length, dt):
    """
    scipy's implementation of Welch's method using hanning window to estimate
    the power spectrum
    @Parameters
        data    -   time series; float vector!
        length  -   length of hanning window, even integer!
    
    @Return:
        powerspectrum, frequencies
    """
    f, pxx = scipy.signal.welch(data, fs=1/dt, window='hanning', nperseg=int(length), noverlap=int(length/2))
    return pxx, f

def smooth_data(x, sig):
    """
    y = smooth_data(x, sig)
    smooth data vector @x with gaussian kernal
    with standard deviation $sig
    """
    sig = float(sig)
    if sig == 0.0:
        return x
        
    # gaussian:
    gauss = lambda (x, sig) : (1/(sig*np.sqrt(2.*np.pi)))*np.exp(-(x*x)/(2.*sig*sig))

    p = 1000000000
    L = 10.
    while (p > p):
        L = L+10
        p = gauss((L, sig))

    F = map(lambda (x): gauss((x, sig)), np.arange(-L, L+1.))
    F = F / np.sum(F)
    
    return scipy.signal.fftconvolve(x, F, 'same')

def recursive_spectrogram(EEG, EMG, sf=0.3, alpha=0.3):

    len_eeg = len(EEG)
    fdt = 2.5
    SR = 1000.0
    swin = int(np.round(SR)*5.0)
    swinh = int(swin/2.0)
    fft_win = int(swin/5.0)
    spoints = int(np.floor(len_eeg/swinh))

    # SE = np.zeros((fft_win/2+1, spoints))
    # SM = np.zeros((fft_win/2+1, spoints))


    x_e = EEG[0:swin]
    [p_e,f_e] = power_spectrum(x_e.astype('float'), fft_win, 1.0/SR)
    p_e = smooth_data(p_e,sf)
    # SE[:,i] = alpha*p + (1-alpha) * SE[:,i-1]

    x_m = EMG[0:swin]
    [p_m,f_m] = power_spectrum(x_m.astype('float'), fft_win, 1.0/SR)
    p_m = smooth_data(p_m,sf)
    # SM[:,i] = alpha*p + (1-alpha) * SM[:,i-1]

    return p_e, p_m, f_e, f_m

def load_params(path, param_file):
    """
    load parameter file generated by &recursive_sleepstate_rem || &recursive_sleepstate_nrem
    @Return:
        Dictionary: Parameter --> Value
    """ 
    import re

    try:   
        fid = open(os.path.join(path, param_file), 'r')
        lines = fid.readlines()
        params = {}
        for line in lines:
            if re.match('^[\S_]+:', line):
                a = re.split('\s+', line)
                key = a[0][:-1]
                params[key] = a[1:-1]
                
        # transform number strings to floats
        for k in params.keys():
            vals = params[k] 
            new_vals = []
            for v in vals:
                if re.match('^[\d\.]+$', v):
                    new_vals.append(float(v))
                else:
                    new_vals.append(v)
            params[k] = new_vals
                        
        return params

    except:
        return {}

class mouse_plotObj:

    def __init__(self, ID, position, params = {}):
        self.name = ID
        self.position = position
        self.prem = 0
        self.pow_muh = []
        # self.rem_hist = []
        self.past_len = int(120/2.5)
        self.num_iter = 0
        self.bern = np.random.binomial(1, 0.50 ,1000)

        self.buffer_e = np.ndarray(0)
        self.buffer_m = np.ndarray(0)
        self.rawtrace = list(np.zeros(5000))
        self.EEG_2_5 = np.ndarray(0)
        self.EMG_2_5 = np.ndarray(0)
        self.EEG_5 = np.ndarray(0)
        self.EMG_5 = np.ndarray(0)
        self.spectro_bufE = np.zeros((240,501))
        self.spectro_bufM = np.zeros((240,501))

        step = 4*(position-1)
        if bool(params):
            self.thr_delta = params['THR_DELTA'][0]
            self.thr_deltap = np.ones(240)*self.thr_delta
            self.thr_th_delta1 = params['THR_TH_DELTA'][0]
            self.thr_th_delta1p = np.ones(240)*self.thr_th_delta1
            self.thr_th_delta2 = params['THR_TH_DELTA'][1]
            self.thr_th_delta2p = np.ones(240)*self.thr_th_delta2
            self.thr_mu = params['THR_MU'][0]
            self.thr_mup = np.ones(240)*self.thr_mu
            self.channels = params['ch_alloc'][0]
            self.eeg_idx = self.channels.find('E') + step
            self.emg_idx = self.channels.find('M') + step
        else:
            # Set default values
            self.thr_delta = 70000
            self.thr_deltap = np.ones(240)*self.thr_delta
            self.thr_th_delta1 = 2.5
            self.thr_th_delta1p = np.ones(240)*self.thr_th_delta1
            self.thr_th_delta2 = 1.5
            self.thr_th_delta2p = np.ones(240)*self.thr_th_delta2
            self.thr_mu = 50000
            self.thr_mup = np.ones(240)*self.thr_mu
            self.channels = 'meEM'
            self.eeg_idx = self.channels.find('E') + step
            self.emg_idx = self.channels.find('M') + step

        self.delta_h = list(np.zeros(240))
        self.mu_h = list(np.zeros(240))
        self.theta_h = list(np.zeros(240))
        self.rem_h = list(np.zeros(240))
        self.th_delta_h = list(np.zeros(240))

        self.image_fft = pg.ImageItem()



######## Main QThread objects and functions ########

def time2display(time_rem):
    tm,ts = np.divmod(int(time_rem), 60)
    th,tm = np.divmod(tm,60)
    if len(str(tm)) == 1:
        minute = "0" + str(tm)
    else:
        minute = str(tm)    
    if len(str(ts)) == 1:
        second = "0" + str(ts)
    else:
        second = str(ts)
    time_display = str(th) + ":" + minute + ":" + second
    return time_display

class worker_countdown(QObject):
    """
    QThread object that runs timer for the experiment. 
    This object is crucial for displaying the time count down until the experiment finished
    Initiated with start button (connected to start_clicked).

    On Delay:
        Time ticks until delay is finished, then goes into the actual count down.
        This function allows the actual data acquisition to start after a certain delay
    When Delay is finished (or if delay is set as 0):
        Still goes through the same process of finishing (ptimeDone) the delay mode,
        then goes into the count down

    """

    signal_countdownDisplay = pyqtSignal(float, str)
    signal_done = pyqtSignal()
    signal_delayDone = pyqtSignal()


    def __init__(self, start_time = 0, expdur = 0, delay = 0):
        super(worker_countdown, self).__init__()
        self.countdown_on = False
        self.start_time = start_time
        self.expdur = expdur
        self.delay = delay
        self.delay_finished = False


    @pyqtSlot()
    def run_countdown(self):
        while self.countdown_on:
            time_rem = (self.expdur*60*60 + self.delay*60) - (time.time()-self.start_time)
            delay_rem = (self.delay*60) - (time.time()-self.start_time)

            # send delay done signal without ol mode
            if time_rem - self.expdur*60*60 < 0.001 and not self.delay_finished:
                self.delay_finished = True
                self.signal_delayDone.emit()

            # Emit signal for time remaining to be displayed
            if self.delay_finished:
                self.signal_countdownDisplay.emit(time_rem, time2display(time_rem))

            else:
                self.signal_countdownDisplay.emit(time_rem, "D: " + time2display(delay_rem))

            # Finish countdown
            if time_rem < 0.001:
                self.signal_done.emit()

            time.sleep(0.1)

class worker_pcountdown(QObject):
    """
    QThread object that run when the open-loop mode has been turned on. This keeps track of
    time gaps between pulse trains (properties of the pulse trains are set using GUI inputs).
    Works very similarly to TotTime_counter, but this one runs a separate counter to count down
    time for the open-loop pulses.

    This object is supposed to close some time before the experiment ends (i.e. when the
    stop_clicked function is run to stop the recording)
    """

    signal_pcountdownDisplay = pyqtSignal(float, str)
    signal_firePulses = pyqtSignal()

    def __init__(self, expdur = 0 , puldur = 0, pt_start = 0, minpg = 15, maxpg = 25):
        super(worker_pcountdown, self).__init__()
        self.pcountdown_on = False
        self.pstart_time = pt_start
        self.puldur = puldur
        self.minpg = minpg
        self.maxpg = maxpg
        

    def setPulgap(self):
        if self.minpg*60 < self.puldur:
            pulGap = int(np.random.uniform(self.puldur+10, self.maxpg*60))
        elif self.maxpg*60 < self.puldur:
            pulGap = int(np.random.uniform(self.puldur+10, self.puldur+60))
        else:
            pulGap = int(np.random.uniform(self.minpg, self.maxpg)*60)
        return pulGap


    def run_pcount(self):
        self.pulGap = self.setPulgap()
        while self.pcountdown_on:
            ptime_rem = self.pulGap - (time.time()-self.pstart_time)
            if ptime_rem < 0.001:
                self.signal_firePulses.emit()
                # reset pulse gap
                self.pstart_time = time.time()
                self.pulGap = self.setPulgap()

            self.signal_pcountdownDisplay.emit(ptime_rem, time2display(ptime_rem))

            time.sleep(0.2)

class worker_camera(QObject):
    """
    QThread object that runs the camera. Its signals display camera frames on the GUI and it also writes
    video frames to an MKV stack.

    One recently aadded feature is the self.f and self.f2 that writes timestamps for the video frames in 
    a txt file.

    Because of the way PyCapture2 package generates the image buffers (into a long list of pixel values), there is a bunch of numpy flipping
    and transposing to get the image shape write to display it properly. I am guessing this is where the
    inefficiency is coming from as each line requires new memory.

    Also, there are two cameras in the same QObject that run at the same time. There should really be one object for
    each camera. The logic behind defining this class as such was that I tried doing so, but failed to create two
    individual video files. This was probably because I didn't use the right fourcc (some of the writer codecs can only be used one at a time. For example, XVID and H264.
    The only ones that worked were for writing from two cameras were MJPG and DIVX). It should work now with using the write codec, but needs to be revised.
    """

    signal_camFrame = pyqtSignal(str, np.ndarray, str, int)

    def __init__(self, preview_or_record, cam, cam_num):
        super(worker_camera, self).__init__()
        self.preview_or_record = preview_or_record
        self.cam = cam
        self.cam_num = cam_num
        self.camera_on = False
        self.writer = 0
        self.prev_timestamp = 0
        

    @pyqtSlot()
    def run_camera(self):
        """
        Commented areas for start_clicked
        """

        if self.preview_or_record == 'R':
            # self.f = open("cam1_timestamps.txt","w+")
            self.cam.writeRegister(0x1508, 0x82000000) #Turns strobe on

        elif self.preview_or_record == 'P':
            self.cam.writeRegister(0x1508, 0x80000000) #Turns strobe off

        while self.camera_on:
            try:
                image = self.cam.retrieveBuffer()
            except PyCapture2.Fc2error as fc2Err:
                print "Error retrieving buffer : ", fc2Err
                continue

            self.img_timestamp = image.getTimeStamp()
            if len(str(self.img_timestamp.microSeconds)) == 6:
                self.str_timestamp = str(self.img_timestamp.seconds)[-6:] + '.' + str(self.img_timestamp.microSeconds) + '\r\n'
            else:
                self.str_timestamp = str(self.img_timestamp.seconds)[-6:] + '.0' + str(self.img_timestamp.microSeconds) + '\r\n'

            imgdat = image.getData()
            imgnp = np.transpose(np.array(imgdat).reshape(image.getRows(), image.getCols()))
            self.prev_timestamp = self.img_timestamp

            self.signal_camFrame.emit(self.preview_or_record, imgnp, self.str_timestamp, self.cam_num)
            
            time.sleep(0.06)

class worker_buffer(QObject):

    signal_new5sec = pyqtSignal(object, str)
    signal_EEGraw = pyqtSignal(list, str)

    def __init__(self, od, mouseObjs, switch = 0):
        super(worker_buffer, self).__init__()
        self.odir = od
        self.fid = open(self.odir + '/amplifier.dat', 'rb')
        self.tid = open(self.odir + '/time.dat', 'r')
        self.switch = switch
        self.new_data = np.fromfile(self.fid, dtype='int16')
        self.new_time = np.fromfile(self.tid, dtype='int32')
        self.mouseObjs = mouseObjs
        self.numchans = 0
        self.alpha = 0.3
        self.r_delta = [0.5, 4]
        self.r_theta = [5,12]
        self.r_mu = [300, 500]
        for mouse in mouseObjs:
            self.numchans += len(mouseObjs[mouse].channels)

    def update_spec(self, mouseObj, m_idx):
        if len(mouseObj.EEG_5) >= 5000:
            p_e, p_m, f_e, f_m = recursive_spectrogram(mouseObj.EEG_5, mouseObj.EMG_5)

            SE = self.alpha*p_e + (1-self.alpha) * mouseObj.spectro_bufE[-1,:]
            SM = self.alpha*p_m + (1-self.alpha) * mouseObj.spectro_bufM[-1,:]

            # power calculation

            i_delta = np.where((f_e >= self.r_delta[0]) & (f_e <= self.r_delta[1]))[0]
            i_theta = np.where((f_e >= self.r_theta[0]) & (f_e <= self.r_theta[1]))[0]
            i_mu = np.where((f_m >= self.r_mu[0]) & (f_m <= self.r_mu[1]))[0]
            
            pow_delta = np.sum(SE[i_delta])
            mouseObj.delta_h.append(pow_delta)
            mouseObj.delta_h = mouseObj.delta_h[-240:]

            pow_theta = np.sum(SE[i_theta])
            mouseObj.theta_h.append(pow_theta)
            mouseObj.theta_h = mouseObj.theta_h[-240:]

            th_delta = np.divide(pow_theta, pow_delta)
            mouseObj.th_delta_h.append(th_delta)
            mouseObj.th_delta_h = mouseObj.th_delta_h[-240:]


            pow_mu = np.sum(SM[i_mu])
            mouseObj.pow_muh.append(pow_mu)
            mouseObj.mu_h.append(pow_mu)
            mouseObj.mu_h = mouseObj.mu_h[-240:]


            # determine rem state

            if (mouseObj.prem == 0 and pow_delta < mouseObj.thr_delta and pow_mu < mouseObj.thr_mu):
            ### could be REM
            
                if (th_delta > mouseObj.thr_th_delta1):
                ### we are potentially entering REM
                    if (mouseObj.past_len < mouseObj.num_iter):
                        past_len = mouseObj.past_len
                    else:
                        past_len = mouseObj.num_iter

                    # count the percentage of brainstate bins with elevated EMG power
                    if past_len != 0:
                        c_mu = np.sum(np.where(mouseObj.pow_muh[(past_len*-1):]>mouseObj.thr_mu)[0] ) / past_len

                        if c_mu < 0.2: # 0.2 = past_mu previously
                        ### we are in REM
                            mouseObj.prem = 1  # turn laser on

            # We are currently in REM; do we stay there?
            if mouseObj.prem == 1:
                ### REM continues, if theta/delta is larger than soft threshold and if there's
                ### no EMG activation
                if ((th_delta > mouseObj.thr_th_delta2) and (pow_mu < mouseObj.thr_mu)):
                    mouseObj.prem = 1
                else:
                    mouseObj.prem = 0 #turn laser off
                    mouseObj.bern_counter += 1

            # self.rem_hist.append(self.prem)
            mouseObj.rem_h.append(mouseObj.prem)
            mouseObj.rem_h = mouseObj.rem_h[-240:]
            

            # if self.prem == 2:
            #     self.prem = 1

            # Buffer add

            mouseObj.num_iter += 1

            mouseObj.spectro_bufE = np.vstack([mouseObj.spectro_bufE, [SE]])[1:,:]
            mouseObj.spectro_bufM = np.vstack([mouseObj.spectro_bufM, [SM]])[1:,:]

            self.signal_new5sec.emit(mouseObj, m_idx)


    def rt_spectrogram(self, mouseObj, m_idx):
        mouseObj.EEG_5 = np.append(mouseObj.EEG_5, mouseObj.EEG_2_5)
        mouseObj.EMG_5 = np.append(mouseObj.EMG_5, mouseObj.EMG_2_5)
        
        self.update_spec(mouseObj, m_idx)

        if len(mouseObj.EEG_5) >= 5000:
            mouseObj.EEG_5 = mouseObj.EEG_2_5
            mouseObj.EMG_5 = mouseObj.EMG_2_5
        


        # we need: eeg_idx, emg_idx, new5_e, new5_m, 
    def run_it(self):

        while self.switch == 1:
            self.new_data = np.fromfile(self.fid, dtype='int16')

            if len(self.new_data) > 1:
                for mouse in self.mouseObjs:
                    mouse_eidx = self.mouseObjs[mouse].eeg_idx
                    mouse_midx = self.mouseObjs[mouse].emg_idx
                    self.mouseObjs[mouse].buffer_e = np.append(self.mouseObjs[mouse].buffer_e, self.new_data[mouse_eidx::self.numchans])
                    self.mouseObjs[mouse].buffer_m = np.append(self.mouseObjs[mouse].buffer_m, self.new_data[mouse_midx::self.numchans])
                    self.signal_EEGraw.emit(list(self.new_data[mouse_eidx::self.numchans]), mouse)

                if len(self.mouseObjs[mouse].buffer_e) >= 2500:
                    for mouse in self.mouseObjs:
                        self.mouseObjs[mouse].EEG_2_5 = self.mouseObjs[mouse].buffer_e[:2500]
                        self.mouseObjs[mouse].buffer_e = self.mouseObjs[mouse].buffer_e[2500:]
                        self.mouseObjs[mouse].EMG_2_5 = self.mouseObjs[mouse].buffer_m[:2500]
                        self.mouseObjs[mouse].buffer_m = self.mouseObjs[mouse].buffer_m[2500:]
                        self.rt_spectrogram(self.mouseObjs[mouse], mouse)

            time.sleep(0.01)



######## Core GUI class ########

class main(QtWidgets.QMainWindow):
    """
    This class contains every bit of information that the GUI needs to process information.
    """

    def __init__(self):

        super(main, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.setWindowIcon(QtGui.QIcon('sleepm.png'))
        self.define_variables()
        self.load_setup('default_settings.txt')
        self.connect_signals()

        #### Start from default setup ####
        self.disable_comment(True)
        self.user_inputSetup()

    def define_variables(self):
        #### GUI placeholder variables
        self.cam1 = None
        self.cam2 = None

        #### Flir Camera settings
        self.bus = PyCapture2.BusManager()
        # Video Modes
        self.vidMOD = 0x604
        self.MODE_0 = 0x00000000 #Full resolution
        self.MODE_1 = 0x20000000 #Half resolution
        self.MODE_5 = 0xA0000000 #Quarter resolution
        # Switching on Strobe Mode
        self.GPIO_pin2_setting = 0x1130
        self.GPIO_pin2_outVal = 0x80080001
        self.pin2_strobecnt = 0x1508
        self.StrobeOff = 0x80000000
        self.StrobeOn = 0x82000000

        #### GUI status variables
        self.rpi_on = False
        self.ard_on = False
        self.cam1_connected = False
        self.cam2_connected = False
        self.start_on = False
        self.preview_on = False
        self.trigger_on = False
        self.plotter_on = False
        self.places = [False, False, False, False]

        #### Range variables for plotting
        self.pos = np.array([0., 0.05, .2, .4, .6, .9])
        self.color = np.array([[0, 0, 0, 255], [0,0,255,255], [0,255,0,255], [255,255,0, 255], (255,165,0,255), (255,0,0, 255)], dtype=np.ubyte)
        self.cmap = pg.ColorMap(self.pos, self.color)
        self.lut = self.cmap.getLookupTable(0.0, 1.0, 256)

        #### GUI input variable dictionaries ####
        ## Protocol ##
        ## QRadioButton
        # setChecked() - mark checked 
        # isChecked() - checks state and returns True or False
        self.protocols = {}
        self.protocols['option_default'] = self.ui.option_default
        self.protocols['option_ol'] = self.ui.option_ol
        self.protocols['option_cl'] = self.ui.option_cl
        self.protocols['option_remdep'] = self.ui.option_remdep
        self.protocols['option_nremdep'] = self.ui.option_nremdep
        
        ## Parameters ##
        ## QSpinBox / QDoubleSpinBox (integer / double)
        # value() - returns the value of the spinbox input
        self.parameters = {}
        self.parameters['sr'] = self.ui.sr
        self.parameters['delay'] = self.ui.delay
        self.parameters['expdur'] = self.ui.expdur
        self.parameters['pulsedur'] = self.ui.pulsedur
        self.parameters['hi'] = self.ui.hi
        self.parameters['lo'] = self.ui.lo
        self.parameters['maxPG'] = self.ui.maxPG
        self.parameters['minPG'] = self.ui.minPG

        ## Mouse ID ##
        ## QCheckBox
        # checkState() - returns 2 if true (different from QRadioButton)
        # setChecked() - mark checked
        ## QLineEdit
        # text() - returns the input text
        # clear() - clears the input text
        self.mouseIDs = {}
        self.mouseIDs['m1chk'] = self.ui.m1chk
        self.mouseIDs['m2chk'] = self.ui.m2chk
        self.mouseIDs['m3chk'] = self.ui.m3chk
        self.mouseIDs['m4chk'] = self.ui.m4chk
        self.mouseIDs['id1'] = self.ui.id1
        self.mouseIDs['id2'] = self.ui.id2
        self.mouseIDs['id3'] = self.ui.id3
        self.mouseIDs['id4'] = self.ui.id4
        self.mouseIDs['ch1'] = self.ui.ch1
        self.mouseIDs['ch2'] = self.ui.ch2
        self.mouseIDs['ch3'] = self.ui.ch3
        self.mouseIDs['ch4'] = self.ui.ch4
        self.mouseIDs['l1'] = self.ui.l1
        self.mouseIDs['l2'] = self.ui.l2
        self.mouseIDs['l3'] = self.ui.l3
        self.mouseIDs['l4'] = self.ui.l4

        ## Connect Devices ##
        self.devices = {}
        self.devices['connect_controller'] = self.ui.connect_controller
        self.devices['connect_c1'] = self.ui.connect_c1
        self.devices['connect_c2'] = self.ui.connect_c2
        self.devices['led_controller'] = self.ui.led_controller
        self.devices['led_cam1'] = self.ui.led_cam1
        self.devices['led_cam2'] = self.ui.led_cam2

        ## Control ##
        self.controls = {}
        self.controls['preview'] = self.ui.preview
        self.controls['startbutton'] = self.ui.startbutton
        self.controls['stopbutton'] = self.ui.stopbutton

        ## Pulse Control ##
        self.pulseControls = {}
        self.pulseControls['hi_c'] = self.ui.hi_c
        self.pulseControls['lo_c'] = self.ui.lo_c
        self.pulseControls['dur_c'] = self.ui.dur_c
        self.pulseControls['continuous'] = self.ui.continuous
        self.pulseControls['c_on'] = self.ui.c_on
        self.pulseControls['c_off'] = self.ui.c_off

        ## Comments ##
        ## QTextEdit
        # toPlainText() - returns the text in string
        # clear() - clears the input text
        self.commentItems = {}
        self.commentItems['commentHist'] = self.ui.commentHist
        self.commentItems['commentbox'] = self.ui.commentbox
        self.commentItems['entercomment'] = self.ui.entercomment

        ## Cameras ## 
        ## pg.GraphicsView
        ## pg.GraphicsLayoutWidget
        # setImage(buffer)
        self.cam1view = self.ui.cam1view
        self.cam2view = self.ui.cam2view
        self.graphicsView = self.ui.graphicsView

        ## Thresholds ##
        self.thresholds = {}
        self.thresholds['threshDelta1'] = self.ui.threshDelta1
        self.thresholds['threshDelta2'] = self.ui.threshDelta2
        self.thresholds['threshDelta3'] = self.ui.threshDelta3
        self.thresholds['threshDelta4'] = self.ui.threshDelta4

        self.thresholds['threshUDelta1'] = self.ui.threshUDelta1
        self.thresholds['threshUDelta2'] = self.ui.threshUDelta2
        self.thresholds['threshUDelta3'] = self.ui.threshUDelta3
        self.thresholds['threshUDelta4'] = self.ui.threshUDelta4

        self.thresholds['threshLDelta1'] = self.ui.threshLDelta1
        self.thresholds['threshLDelta2'] = self.ui.threshLDelta2
        self.thresholds['threshLDelta3'] = self.ui.threshLDelta3
        self.thresholds['threshLDelta4'] = self.ui.threshLDelta4

        self.thresholds['threshThd1'] = self.ui.threshThd1
        self.thresholds['threshThd2'] = self.ui.threshThd2
        self.thresholds['threshThd3'] = self.ui.threshThd3
        self.thresholds['threshThd4'] = self.ui.threshThd4

        self.thresholds['threshThdl1'] = self.ui.threshThdl1
        self.thresholds['threshThdl2'] = self.ui.threshThdl2
        self.thresholds['threshThdl3'] = self.ui.threshThdl3
        self.thresholds['threshThdl4'] = self.ui.threshThdl4

        self.thresholds['threshMu1'] = self.ui.threshMu1
        self.thresholds['threshMu2'] = self.ui.threshMu2
        self.thresholds['threshMu3'] = self.ui.threshMu3
        self.thresholds['threshMu4'] = self.ui.threshMu4


        #### Error Dialog Handle ####
        self.error_dialog = QMessageBox()
        self.error_dialog.setIcon(QtWidgets.QMessageBox.Critical)
        self.error_dialog.setWindowTitle("Error")
        self.error_dialog.setWindowIcon(QtGui.QIcon('sleepm.png'))

    def connect_signals(self):
        #### Connecting Signals and Slots ####
        for protocol in self.protocols:
            self.protocols[protocol].clicked.connect(self.user_inputSetup)
        self.devices['connect_controller'].clicked.connect(self.comm_connect)
        self.devices['connect_c1'].clicked.connect(self.cam1_setup)
        self.devices['connect_c2'].clicked.connect(self.cam2_setup)
        self.controls['preview'].clicked.connect(self.preview_clicked)
        self.controls['startbutton'].clicked.connect(self.start_clicked)
        self.controls['stopbutton'].clicked.connect(self.stop_clicked)
        self.ui.actionLoad_Settings.triggered.connect(lambda: self.load_setup(os.path.basename(QFileDialog.getOpenFileName(self, "Select your setting (txt)")[0])))
        self.ui.actionSave_Settings.triggered.connect(lambda: self.save_setup(QFileDialog.getSaveFileName(self, "Save your settings")[0]))
        # self.pulseControls['c_on'].clicked.connect(self.pulon_clicked)
        # self.pulseControls['c_off'].clicked.connect(self.puloff_clicked)
        self.commentItems['entercomment'].clicked.connect(self.submit_comment)

    def disable_customPulse(self, disable):
        for item in self.pulseControls:
            self.pulseControls[item].setDisabled(disable)

    @pyqtSlot()
    def user_inputSetup(self):
        """Disable settings used for other protocols"""
        if self.protocols['option_default'].isChecked():
            self.parameters['pulsedur'].setDisabled(True)
            self.parameters['hi'].setDisabled(True)
            self.parameters['lo'].setDisabled(True)
            self.parameters['maxPG'].setDisabled(True)
            self.parameters['minPG'].setDisabled(True)
            for item in self.thresholds:
                self.thresholds[item].setDisabled(True)
            self.disable_customPulse(False)

        elif self.protocols['option_ol'].isChecked():
            self.parameters['pulsedur'].setDisabled(False)
            self.parameters['hi'].setDisabled(False)
            self.parameters['lo'].setDisabled(False)
            self.parameters['maxPG'].setDisabled(False)
            self.parameters['minPG'].setDisabled(False)
            for item in self.thresholds:
                self.thresholds[item].setDisabled(True)
            self.disable_customPulse(True)
        elif self.protocols['option_cl'].isChecked():
            self.parameters['pulsedur'].setDisabled(False)
            self.parameters['hi'].setDisabled(False)
            self.parameters['lo'].setDisabled(False)
            self.parameters['maxPG'].setDisabled(True)
            self.parameters['minPG'].setDisabled(True)
            for item in self.thresholds:
                self.thresholds[item].setDisabled(False)
            self.disable_customPulse(False)
        else:
            self.parameters['pulsedur'].setDisabled(True)
            self.parameters['hi'].setDisabled(True)
            self.parameters['lo'].setDisabled(True)
            self.parameters['maxPG'].setDisabled(True)
            self.parameters['minPG'].setDisabled(True)
            for item in self.thresholds:
                self.thresholds[item].setDisabled(False)
            self.disable_customPulse(False)

    def load_setup(self, setting):

        def set_text(text):
            if params[text]:
                self.mouseIDs[text].setText(params[text][0])
            else:
                self.mouseIDs[text].setText('')

        params = load_params(os.getcwd(), setting)

        try:
            if params['buf_dir'] == []:
                self.buf_dir = str(QFileDialog.getExistingDirectory(self, "Select the directory containing DAT files"))
            else:
                self.buf_dir = params['buf_dir'][0]
            if params['remtxt_dir'] == []:
                self.remtxt_dir = str(QFileDialog.getExistingDirectory(self, "Select path to mouse_rem.txt files"))
            else:
                self.remtxt_dir = params['remtxt_dir'][0]
        except:
            self.error_dialog.setText("Load unsuccesful: There is a problem setting up the directory.")
            self.error_dialog.show()

        try:
            self.protocols[params['protocol'][0]].setChecked(True)

            self.parameters['sr'].setProperty("value", params['sr'][0])
            self.parameters['delay'].setProperty("value", params['delay'][0])
            self.parameters['expdur'].setProperty("value", params['expdur'][0])
            self.parameters['pulsedur'].setProperty("value", params['pulsedur'][0])
            self.parameters['hi'].setProperty("value", params['hi'][0])
            self.parameters['lo'].setProperty("value", params['lo'][0])
            self.parameters['maxPG'].setProperty("value", params['maxPG'][0])
            self.parameters['minPG'].setProperty("value", params['minPG'][0])

            self.mouseIDs['m1chk'].setChecked(params['m1chk'][0])
            self.mouseIDs['m2chk'].setChecked(params['m2chk'][0])
            self.mouseIDs['m3chk'].setChecked(params['m3chk'][0])
            self.mouseIDs['m4chk'].setChecked(params['m4chk'][0])

            set_text('id1')
            set_text('id2')
            set_text('id3')
            set_text('id4')
            set_text('ch1')
            set_text('ch2')
            set_text('ch3')
            set_text('ch4')
            set_text('l1')
            set_text('l2')
            set_text('l3')
            set_text('l4')

            self.thresholds['threshDelta1'].setProperty("value", params['threshDelta1'][0])
            self.thresholds['threshDelta2'].setProperty("value", params['threshDelta2'][0])
            self.thresholds['threshDelta3'].setProperty("value", params['threshDelta3'][0])
            self.thresholds['threshDelta4'].setProperty("value", params['threshDelta4'][0])
            self.thresholds['threshUDelta1'].setProperty("value", params['threshUDelta1'][0])
            self.thresholds['threshUDelta2'].setProperty("value", params['threshUDelta2'][0])
            self.thresholds['threshUDelta3'].setProperty("value", params['threshUDelta3'][0])
            self.thresholds['threshUDelta4'].setProperty("value", params['threshUDelta4'][0])
            self.thresholds['threshLDelta1'].setProperty("value", params['threshLDelta1'][0])
            self.thresholds['threshLDelta2'].setProperty("value", params['threshLDelta2'][0])
            self.thresholds['threshLDelta3'].setProperty("value", params['threshLDelta3'][0])
            self.thresholds['threshLDelta4'].setProperty("value", params['threshLDelta4'][0])
            self.thresholds['threshThd1'].setProperty("value", params['threshThd1'][0])
            self.thresholds['threshThd2'].setProperty("value", params['threshThd2'][0])
            self.thresholds['threshThd3'].setProperty("value", params['threshThd3'][0])
            self.thresholds['threshThd4'].setProperty("value", params['threshThd4'][0])
            self.thresholds['threshThdl1'].setProperty("value", params['threshThdl1'][0])
            self.thresholds['threshThdl2'].setProperty("value", params['threshThdl2'][0])
            self.thresholds['threshThdl3'].setProperty("value", params['threshThdl3'][0])
            self.thresholds['threshThdl4'].setProperty("value", params['threshThdl4'][0])
            self.thresholds['threshMu1'].setProperty("value", params['threshMu1'][0])
            self.thresholds['threshMu2'].setProperty("value", params['threshMu2'][0])
            self.thresholds['threshMu3'].setProperty("value", params['threshMu3'][0])
            self.thresholds['threshMu4'].setProperty("value", params['threshMu4'][0])

            self.user_inputSetup()

        except KeyError:
            self.error_dialog.setText("There was at least one missing paramter. Check your settings text file.")
            self.error_dialog.show()

    def save_setup(self, name):
        if name:
            if 'txt' in os.path.basename(name):
                os.remove(name)
                self.save_txt = open(name ,"w+")
            else:
                self.save_txt = open(name + '.txt' ,"w+")

            self.save_txt.write('buf_dir:\t' + self.buf_dir + '\r\n')
            self.save_txt.write('remtxt_dir:\t' + self.remtxt_dir + '\r\n')
            for protocol in self.protocols:
                if self.protocols[protocol].isChecked():
                    self.save_txt.write('protocol:\t' + protocol + '\r\n')
            self.save_txt.write('sr:\t' + str(self.ui.sr.value()) + '\r\n')
            self.save_txt.write('delay:\t' + str(self.ui.delay.value()) + '\r\n')
            self.save_txt.write('expdur:\t' + str(self.ui.expdur.value()) + '\r\n')
            self.save_txt.write('pulsedur:\t' + str(self.ui.pulsedur.value()) + '\r\n')
            self.save_txt.write('hi:\t' + str(self.ui.hi.value()) + '\r\n')
            self.save_txt.write('lo:\t' + str(self.ui.lo.value()) + '\r\n')
            self.save_txt.write('maxPG:\t' + str(self.ui.maxPG.value()) + '\r\n')
            self.save_txt.write('minPG:\t' + str(self.ui.minPG.value()) + '\r\n')
            self.save_txt.write('m1chk:\t' + str(int(bool(self.ui.m1chk.checkState()))) + '\r\n')
            self.save_txt.write('m2chk:\t' + str(int(bool(self.ui.m2chk.checkState()))) + '\r\n')
            self.save_txt.write('m3chk:\t' + str(int(bool(self.ui.m3chk.checkState()))) + '\r\n')
            self.save_txt.write('m4chk:\t' + str(int(bool(self.ui.m4chk.checkState()))) + '\r\n')
            self.save_txt.write('id1:\t' + str(self.ui.id1.text()) + '\r\n')
            self.save_txt.write('id2:\t' + str(self.ui.id2.text()) + '\r\n')
            self.save_txt.write('id3:\t' + str(self.ui.id3.text()) + '\r\n')
            self.save_txt.write('id4:\t' + str(self.ui.id4.text()) + '\r\n')
            self.save_txt.write('ch1:\t' + str(self.ui.ch1.text()) + '\r\n')
            self.save_txt.write('ch2:\t' + str(self.ui.ch2.text()) + '\r\n')
            self.save_txt.write('ch3:\t' + str(self.ui.ch3.text()) + '\r\n')
            self.save_txt.write('ch4:\t' + str(self.ui.ch4.text()) + '\r\n')
            self.save_txt.write('l1:\t' + str(self.ui.l1.text()) + '\r\n')
            self.save_txt.write('l2:\t' + str(self.ui.l2.text()) + '\r\n')
            self.save_txt.write('l3:\t' + str(self.ui.l3.text()) + '\r\n')
            self.save_txt.write('l4:\t' + str(self.ui.l4.text()) + '\r\n')
            self.save_txt.write('threshDelta1:\t' + str(self.ui.threshDelta1.value()) + '\r\n')
            self.save_txt.write('threshDelta2:\t' + str(self.ui.threshDelta2.value()) + '\r\n')
            self.save_txt.write('threshDelta3:\t' + str(self.ui.threshDelta3.value()) + '\r\n')
            self.save_txt.write('threshDelta4:\t' + str(self.ui.threshDelta4.value()) + '\r\n')
            self.save_txt.write('threshUDelta1:\t' + str(self.ui.threshUDelta1.value()) + '\r\n')
            self.save_txt.write('threshUDelta2:\t' + str(self.ui.threshUDelta2.value()) + '\r\n')
            self.save_txt.write('threshUDelta3:\t' + str(self.ui.threshUDelta3.value()) + '\r\n')
            self.save_txt.write('threshUDelta4:\t' + str(self.ui.threshUDelta4.value()) + '\r\n')
            self.save_txt.write('threshLDelta1:\t' + str(self.ui.threshLDelta1.value()) + '\r\n')
            self.save_txt.write('threshLDelta2:\t' + str(self.ui.threshLDelta2.value()) + '\r\n')
            self.save_txt.write('threshLDelta3:\t' + str(self.ui.threshLDelta3.value()) + '\r\n')
            self.save_txt.write('threshLDelta4:\t' + str(self.ui.threshLDelta4.value()) + '\r\n')
            self.save_txt.write('threshThd1:\t' + str(self.ui.threshThd1.value()) + '\r\n')
            self.save_txt.write('threshThd2:\t' + str(self.ui.threshThd2.value()) + '\r\n')
            self.save_txt.write('threshThd3:\t' + str(self.ui.threshThd3.value()) + '\r\n')
            self.save_txt.write('threshThd4:\t' + str(self.ui.threshThd4.value()) + '\r\n')
            self.save_txt.write('threshThdl1:\t' + str(self.ui.threshThdl1.value()) + '\r\n')
            self.save_txt.write('threshThdl2:\t' + str(self.ui.threshThdl2.value()) + '\r\n')
            self.save_txt.write('threshThdl3:\t' + str(self.ui.threshThdl3.value()) + '\r\n')
            self.save_txt.write('threshThdl4:\t' + str(self.ui.threshThdl4.value()) + '\r\n')
            self.save_txt.write('threshMu1:\t' + str(self.ui.threshMu1.value()) + '\r\n')
            self.save_txt.write('threshMu2:\t' + str(self.ui.threshMu2.value()) + '\r\n')
            self.save_txt.write('threshMu3:\t' + str(self.ui.threshMu3.value()) + '\r\n')
            self.save_txt.write('threshMu4:\t' + str(self.ui.threshMu4.value()) + '\r\n')
            self.save_txt.write('\r\n')
            self.save_txt.close()







    def arduino_mode_on(self):
        port_avail = list(com_read.comports())
        for p in port_avail:
            if "Ard" in p[1] or "USB" in p[1]:
                COM = p[0]
        try:
            self.comPort = serial.Serial(COM)
            self.devices['led_controller'].setPixmap(QtGui.QPixmap("led_on"))
            self.ard_on = True
            self.controls['startbutton'].setDisabled(True)
            QTimer.singleShot(1200, lambda: self.controls['startbutton'].setDisabled(False))
        except ValueError:
            self.error_dialog.setText("There is a problem connecting to the ComPort. Try reconnecting the USB")
            self.error_dialog.show()
        except serial.SerialException:
            self.error_dialog.setText("There is a problem connecting to the ComPort. Try reconnecting the USB")
            self.error_dialog.show()
        except NameError:
            self.error_dialog.setText("There is no arduino available")
            self.error_dialog.show()

    def arduino_disconnect(self):
        if self.ard_on:
            self.comPort.close()
            self.devices['led_controller'].setPixmap(QtGui.QPixmap("led_off"))
            self.ard_on = False

    # def raspi_mode_on(self, ip):

    # def raspi_disconnect(self):

    @pyqtSlot()
    def comm_connect(self):
        if not self.ard_on and not self.rpi_on:
            ip_address, okPressed = QInputDialog.getText(self, "Connecting to RPi","Type the IP address of your RPi (ie. 10.103.215.103) or skip to disregard", QLineEdit.Normal, "")
            if okPressed:
                if ip_address == '':
                    self.arduino_mode_on()
                else:
                    self.raspi_mode_on(ip_address)
                    
        else:
            if self.ard_on:
                self.arduino_disconnect()
            elif self.rpi_on:
                self.raspi_disconnect()







    @pyqtSlot()
    def cam1_setup(self):
        if not self.cam1_connected:
            self.cam1 = PyCapture2.Camera()
            connection = self.cam_connect(0, self.cam1)
            if connection == 'success':
                self.devices['led_cam1'].setPixmap(QtGui.QPixmap("led_on"))
                self.cam1_connected = True
        else:
            try:
                self.cam1.disconnect()
                self.devices['led_cam1'].setPixmap(QtGui.QPixmap("led_off"))
                self.cam1_connected = False
            except:
                print("There was a problem disconnecting the camera 1")
                pass

    @pyqtSlot()
    def cam2_setup(self):
        if not self.cam2_connected:
            self.cam2 = PyCapture2.Camera()
            connection = self.cam_connect(1, self.cam2)
            if connection == 'success':
                self.devices['led_cam2'].setPixmap(QtGui.QPixmap("led_on"))
                self.cam2_connected = True
        else:
            try:
                self.cam2.disconnect()
                self.devices['led_cam2'].setPixmap(QtGui.QPixmap("led_off"))
                self.cam2_connected = False
            except:
                print("There was a problem disconnecting the camera 2")
                pass

    def cam_connect(self, cam_num, cam):

        def temp_enablebtns():
            self.controls['startbutton'].setDisabled(False)
            self.controls['stopbutton'].setDisabled(False)
            self.controls['preview'].setDisabled(False)

        try:
            
            cam.connect(self.bus.getCameraFromIndex(cam_num))

            self.controls['startbutton'].setDisabled(True)
            self.controls['stopbutton'].setDisabled(True)
            self.controls['preview'].setDisabled(True)
            # Setting Frame Rate
            cam.setProperty(type = PyCapture2.PROPERTY_TYPE.FRAME_RATE, autoManualMode = False)
            cam.setProperty(type = PyCapture2.PROPERTY_TYPE.FRAME_RATE, absControl = True)
            cam.setProperty(type = PyCapture2.PROPERTY_TYPE.FRAME_RATE, absValue = 5.0)

            self.fRateProp = cam.getProperty(PyCapture2.PROPERTY_TYPE.FRAME_RATE)
            self.frame_rate = self.fRateProp.absValue

            cam.writeRegister(self.vidMOD, self.MODE_1)

            cam.writeRegister(self.GPIO_pin2_setting, self.GPIO_pin2_outVal)
            cam.writeRegister(self.pin2_strobecnt, self.StrobeOff)

            QTimer.singleShot(1200, temp_enablebtns)

            return 'success'

        except PyCapture2.Fc2error:
            self.error_dialog.setText("There is a problem connecting to the Camera. Try reconnecting the USB in the right order.")
            self.error_dialog.show()

    def cams_disconnect(self):
        try:
            self.cam1.disconnect()
            self.cam2.disconnect()
            self.cam1_connected = False
            self.cam2_connected = False
        except AttributeError:
            pass

    def start_cameraThread(self, cam, record_or_preview, cam_num):
        camera_thread = QThread(self)
        camera_obj = worker_camera(record_or_preview, cam, cam_num)
        camera_obj.moveToThread(camera_thread)
        camera_obj.camera_on = True
        camera_obj.signal_camFrame.connect(self.process_vid)
        camera_thread.started.connect(camera_obj.run_camera)
        cam.startCapture()
        camera_thread.start()

        return camera_obj, camera_thread

    def stop_cameraThread(self, cam, cam_obj, cam_thread):
        cam.writeRegister(self.pin2_strobecnt, self.StrobeOff)
        cam_obj.camera_on = False
        cam.stopCapture()
        cam_thread.quit()
        cam_thread.wait()

    @pyqtSlot(str, np.ndarray, str, int)
    def process_vid(self, PoR, frame, timestamps, cam_num):

        if PoR == 'R':
            if cam_num == 1:
                if self.mouseIDs['m1chk'].checkState() == 2:
                    self.mkv_writer1.write(np.uint8(frame[0:322,:]))
                if self.mouseIDs['m2chk'].checkState() == 2:
                    self.mkv_writer2.write(np.uint8(frame[322:,:]))
            if cam_num == 2:
                if self.mouseIDs['m3chk'].checkState() == 2:
                    self.mkv_writer3.write(np.uint8(frame[0:322,:]))
                if self.mouseIDs['m4chk'].checkState() == 2:
                    self.mkv_writer4.write(np.uint8(frame[322:,:]))

        if cam_num == 1:
            self.cam1view.setImage(frame)
        if cam_num == 2:
            self.cam2view.setImage(frame)

    @pyqtSlot()
    def preview_clicked(self):
        if not self.cam1_connected and not self.cam2_connected:
            self.error_dialog.setText("You must connect the camera first!")
            self.error_dialog.show()

        elif not self.start_on and not self.preview_on:
            self.controls['preview'].setStyleSheet("background-color: green")
            self.preview_on = True

            for buttons in self.devices:
                if 'led' not in buttons:
                    self.devices[buttons].setDisabled(True)
            for buttons in self.controls:
                if 'preview' not in buttons:
                    self.controls[buttons].setDisabled(True)

            if self.cam1_connected:
                self.cam_obj1, self.cam_thread1 = self.start_cameraThread(self.cam1, 'P', 1)

            if self.cam2_connected:
                self.cam_obj2, self.cam_thread2 = self.start_cameraThread(self.cam2, 'P', 2)


        elif not self.start_on and self.preview_on:
            self.controls['preview'].setStyleSheet(self.controls['stopbutton'].styleSheet())
            self.preview_on = False

            for buttons in self.devices:
                self.devices[buttons].setDisabled(False)
            for buttons in self.controls:
                self.controls[buttons].setDisabled(False)

            if self.cam1_connected:
                self.stop_cameraThread(self.cam1, self.cam_obj1, self.cam_thread1)
                QTimer.singleShot(100, lambda: self.cam1view.clear())

            if self.cam2_connected:
                self.stop_cameraThread(self.cam2, self.cam_obj2, self.cam_thread2)
                QTimer.singleShot(100, lambda: self.cam2view.clear())

    def start_videoRec(self):
        self.fourcc = cv2.VideoWriter_fourcc(*'DIVX')
        if self.cam1_connected:
            if self.mouseIDs['m1chk'].checkState() == 2:
                self.mkv_writer1 = cv2.VideoWriter(self.ui.id1.text() + "_cam_1.mkv", self.fourcc, self.frame_rate, (482, 322), isColor=0)
            if self.mouseIDs['m2chk'].checkState() == 2:
                self.mkv_writer2 = cv2.VideoWriter(self.ui.id2.text() + "_cam_2.mkv", self.fourcc, self.frame_rate, (482, 322), isColor=0)
            self.cam_obj1, self.cam_thread1 = self.start_cameraThread(self.cam1, 'R', 1)

        if self.cam2_connected:
            if self.mouseIDs['m3chk'].checkState() == 2:
                self.mkv_writer3 = cv2.VideoWriter(self.ui.id3.text() + "_cam_3.mkv", self.fourcc, self.frame_rate, (482, 322), isColor=0)
            if self.mouseIDs['m4chk'].checkState() == 2:
                self.mkv_writer4 = cv2.VideoWriter(self.ui.id4.text() + "_cam_4.mkv", self.fourcc, self.frame_rate, (482, 322), isColor=0)
            self.cam_obj2, self.cam_thread2 = self.start_cameraThread(self.cam2, 'R', 2)

    def end_videoRec(self):
        if self.cam1_connected:
            self.stop_cameraThread(self.cam1, self.cam_obj1, self.cam_thread1)
            if self.mouseIDs['m1chk'].checkState() == 2:
                self.mkv_writer1.release()
            if self.mouseIDs['m2chk'].checkState() == 2:
                self.mkv_writer2.release()
            QTimer.singleShot(100, lambda: self.cam1view.clear())

        if self.cam2_connected:
            self.stop_cameraThread(self.cam2, self.cam_obj2, self.cam_thread2)
            if self.mouseIDs['m3chk'].checkState() == 2:
                self.mkv_writer3.release()
            if self.mouseIDs['m4chk'].checkState() == 2:
                self.mkv_writer4.release()
            QTimer.singleShot(100, lambda: self.cam2view.clear())

   




    def create_mouselist(self):
        mouselist = []
        places = []
        if self.mouseIDs['m1chk'].checkState() == 2:
            mouselist.append(self.mouseIDs['id1'].text())
            places.append(True)
        else:
            places.append(False)
        if self.mouseIDs['m2chk'].checkState() == 2:
            mouselist.append(self.mouseIDs['id2'].text())
            places.append(True)
        else:
            places.append(False)
        if self.mouseIDs['m3chk'].checkState() == 2:
            mouselist.append(self.mouseIDs['id3'].text())
            places.append(True)
        else:
            places.append(False)
        if self.mouseIDs['m4chk'].checkState() == 2:
            mouselist.append(self.mouseIDs['id4'].text())
            places.append(True)
        else:
            places.append(False)
        return mouselist, not bool(mouselist), places

    def disable_input(self, disable):
            for protocol in self.protocols:
                self.protocols[protocol].setDisabled(disable)
            for connection in self.devices:
                if 'led' not in connection:
                    self.devices[connection].setDisabled(disable)
            for param in self.parameters:
                self.parameters[param].setDisabled(disable)
            for prop in self.mouseIDs:
                self.mouseIDs[prop].setDisabled(disable)
            if not disable:
                self.user_inputSetup()

    def getTime(self):

        # Create prefix for all files using time library. date_time = "YearMonthDate_HrMinSec", date = "YearMonthDate"

        date_time = str(time.localtime().tm_year)[2:4]
        date = ''
        

        if len(str(time.localtime().tm_mon)) < 2:
            date_time += '0' + str(time.localtime().tm_mon)
            date += '0' + str(time.localtime().tm_mon) + '/'
        else:
            date_time += str(time.localtime().tm_mon)
            date += str(time.localtime().tm_mon) + '/'

        if len(str(time.localtime().tm_mday)) < 2:
            date_time += '0' + str(time.localtime().tm_mday)
            date += '0' + str(time.localtime().tm_mday) + '/'
        else:
            date_time += str(time.localtime().tm_mday)
            date += str(time.localtime().tm_mday) + '/'

        date += str(time.localtime().tm_year)[2:4]

        date_time += str('_')
        if len(str(time.localtime().tm_hour)) < 2:
            date_time += '0' + str(time.localtime().tm_hour)
        else:
            date_time += str(time.localtime().tm_hour)

        if len(str(time.localtime().tm_min)) < 2:
            date_time += '0' + str(time.localtime().tm_min)
        else:
            date_time += str(time.localtime().tm_min)
        if len(str(time.localtime().tm_sec)) < 2:
            date_time += '0' + str(time.localtime().tm_sec)
        else:
            date_time += str(time.localtime().tm_sec)

        time_init = time.localtime()
        curr_time = str(time_init.tm_hour) + ':' + str(time_init.tm_min) + ':' + str(time_init.tm_sec)

        return curr_time, date, date_time

    def setupNotes(self):

        self.timetxt, self.todate, self.todate_full = self.getTime()

        # Writes a txt file to include all experiment setting and variables

        self.txt = open(self.todate_full + "_notes.txt","w+")
        self.txt.write('date:\t' + self.todate + '\r\n')
        self.txt.write('time:\t' + self.timetxt + '\r\n')
        self.txt.write('amplifier:\t' + 'intan' + '\r\n')
        self.txt.write('SR:\t' + str(self.parameters['sr'].value()) + '\r\n')
        self.txt.write('delay:\t' + str(self.parameters['delay'].value()) + '\r\n')
        if self.protocols['option_ol'].isChecked():
            self.txt.write('mode:\t' + 'ol\r\n')
        elif self.protocols['option_cl'].isChecked():
            self.txt.write('mode:\t' + 'cl\r\n')
        elif self.protocols['option_remdep'].isChecked():
            self.txt.write('mode:\t' + 'remdep\r\n')
        elif self.protocols['option_nremdep'].isChecked():
            self.txt.write('mode:\t' + 'nremdep\r\n')
        else:
            self.txt.write('mode:\t' + 'default\r\n')

        if self.protocols['option_ol'].isChecked() or self.protocols['option_cl'].isChecked():
            self.txt.write('laser_hi:\t' + str(self.parameters['hi'].value()) + '\r\n')
            self.txt.write('laser_lo:\t' + str(self.parameters['lo'].value()) + '\r\n')
            self.txt.write('stim_freq:\t' + str(int(1.0/(self.parameters['hi'].value()+self.parameters['lo'].value())/0.001)) + '\r\n')
            if self.protocols['option_ol'].isChecked():
                self.txt.write('laser_dur:\t' + str(self.parameters['pulsedur'].value()) + '\r\n')
        self.txt.write('exp_dur:\t' + str(self.parameters['expdur'].value()) + '\r\n')
        self.txt.write('mouse_ID:\t')
        if self.mouseIDs['m1chk'].checkState() == 2:
            self.txt.write(self.mouseIDs['id1'].text() + '\t')
        else:
            self.txt.write('\t ')
        if self.mouseIDs['m2chk'].checkState() == 2:
            self.txt.write(self.mouseIDs['id2'].text() + '\t')
        else:
            self.txt.write('\t ')
        if self.mouseIDs['m3chk'].checkState() == 2:
            self.txt.write(self.mouseIDs['id3'].text() + '\t')
        else:
            self.txt.write('\t ')
        if self.mouseIDs['m4chk'].checkState() == 2:
            self.txt.write(self.mouseIDs['id4'].text() + '\t')
        else:
            self.txt.write('\t ')

        self.txt.write('\r\n')
        self.txt.write('ch_alloc:\t')
        if self.mouseIDs['m1chk'].checkState() == 2:
            self.txt.write(self.mouseIDs['ch1'].text() + '\t')
        if self.mouseIDs['m2chk'].checkState() == 2:
            self.txt.write(self.mouseIDs['ch2'].text() + '\t')
        if self.mouseIDs['m3chk'].checkState() == 2:
            self.txt.write(self.mouseIDs['ch3'].text() + '\t')
        if self.mouseIDs['m4chk'].checkState() == 2:
            self.txt.write(self.mouseIDs['ch4'].text() + '\t')
        
        self.txt.write('\r\n')
        self.txt.write('laser_used:\t')
        if self.mouseIDs['m1chk'].checkState() == 2:
            self.txt.write(self.mouseIDs['l1'].text() + '\t')
        if self.mouseIDs['m2chk'].checkState() == 2:
            self.txt.write(self.mouseIDs['l2'].text() + '\t')
        if self.mouseIDs['m3chk'].checkState() == 2:
            self.txt.write(self.mouseIDs['l3'].text() + '\t')
        if self.mouseIDs['m4chk'].checkState() == 2:
            self.txt.write(self.mouseIDs['l4'].text() + '\t')

        self.txt.write('\r\n')
        self.txt.write('#Notes:\t')
        self.txt.close()

    def endNotes(self):
        self.txt = open(self.todate_full + "_notes.txt", 'a')
        self.txt.write('\r\n')
        self.totRec_time = int(self.ui.expdur.value()*60*60) - self.time_rem
        if self.totRec_time > 0:
            self.mr,self.srem = np.divmod(self.totRec_time, 60)
            self.hr,self.mr = np.divmod(self.mr,60)
            self.txt.write('actual_duration:\t'+ str(int(self.hr)) + 'h:' + str(int(self.mr)) + 'm:' + str(int(self.srem)) + 's')
            self.txt.close()
        else:
            self.txt.write('actual_duration:\t'+ '0h:00m:00s')
            self.txt.close()








    def begin_countdown(self):
        timer_thread = QThread(self)
        timer_obj = worker_countdown(0, self.ui.expdur.value(), self.ui.delay.value())
        timer_obj.moveToThread(timer_thread)
        timer_obj.signal_countdownDisplay.connect(self.update_countdown)
        timer_obj.signal_done.connect(self.stop_clicked)
        timer_obj.signal_delayDone.connect(self.beginProtocol)
        timer_thread.started.connect(timer_obj.run_countdown)
        return timer_obj, timer_thread

    def end_countdown(self):
        self.countdown_obj.countdown_on = False
        self.countdown_thread.quit()
        self.countdown_thread.wait()
        self.update_countdown()

        if self.trigger_on:
            self.trigger_on = False
            self.comPort.write(bytearray(b'E\n'))

    @pyqtSlot(float, str)
    def update_countdown(self, time_rem = 0, time_display = '0'):
        self.time_rem = time_rem
        if self.countdown_obj.countdown_on:
            self.ui.t_rem.setText(QtCore.QCoreApplication.translate("MainWindow", time_display))
        else:
            self.ui.t_rem.setText(QtCore.QCoreApplication.translate("MainWindow", "IDLE"))

    def begin_pcountdown(self):
        ptimer_thread = QThread(self)
        ptimer_obj = worker_pcountdown(self.ui.expdur.value(), self.ui.pulsedur.value(), time.time(), self.ui.minPG.value(), self.ui.maxPG.value())
        ptimer_obj.moveToThread(ptimer_thread)
        ptimer_obj.pcountdown_on = True
        ptimer_obj.signal_pcountdownDisplay.connect(self.update_pcountdown)
        ptimer_obj.signal_firePulses.connect(self.ol_firePulses)
        ptimer_thread.started.connect(ptimer_obj.run_pcount)
        ptimer_thread.start()
        return ptimer_obj, ptimer_thread

    def end_pcountdown(self):
        self.pcountdown_obj.pcountdown_on = False
        self.pcountdown_thread.quit()
        self.pcountdown_thread.wait()
        self.update_pcountdown()

    def ol_firePulses(self):
        if self.ard_on:
            self.comPort.write(bytearray(b'R\n'))
        elif self.rpi_on:
            # add lines here #
            pass

    @pyqtSlot(float, str)
    def update_pcountdown(self, ptime_rem = 0, ptime_display = '0'):
        if self.pcountdown_obj.pcountdown_on and self.time_rem < self.ui.maxPG.value()*60 + 20:
            self.end_pcountdown()
        if self.pcountdown_obj.pcountdown_on:
            self.ui.p_rem.setText(QtCore.QCoreApplication.translate("MainWindow", ptime_display))
        else:
            self.ui.p_rem.setText(QtCore.QCoreApplication.translate("MainWindow", "IDLE"))







    def setupProtocol(self):
        if self.ard_on and self.protocols['option_ol'].isChecked:
            try:
                self.comPort.write(bytearray(b'H' + str(self.parameters['hi'].value()) + '\n'))
                self.comPort.write(bytearray(b'L' + str(self.parameters['lo'].value()) + '\n'))
                self.comPort.write(bytearray(b'D' + str(self.parameters['pulsedur'].value()) + '\n'))
                if self.parameters['delay'].value() != 0:
                    self.ui.p_rem.setText(QtCore.QCoreApplication.translate("MainWindow", "On Delay"))
            except:
                self.error_dialog.setText("Pulse information tranfer failed")
                self.error_dialog.show()

        # elif self.rpi_on:

        self.countdown_obj, self.countdown_thread = self.begin_countdown()
        self.countdown_obj.countdown_on = True
        self.countdown_obj.start_time = time.time()
        self.countdown_thread.start()

    @pyqtSlot()
    def beginProtocol(self):
        
        self.run_default()

        if self.protocols['option_ol'].isChecked():
            self.pcountdown_obj, self.pcountdown_thread = self.begin_pcountdown()
        elif self.protocols['option_cl'].isChecked():
            self.run_cl()
        elif self.protocols['option_remdep'].isChecked():
            self.run_cl()
        elif self.protocols['option_nremdep'].isChecked():
            self.run_cl()

    def run_default(self):
        if self.ard_on:
            self.comPort.write(bytearray(b'S\n'))
            self.trigger_on = True
        elif self.rpi_on:
            # add lines here for rpi #
            pass
        
        
    # def run_cl(self):

        # rem state on/off
        # if self.ardorrasp == 'r':
        #     self.s.send('START')

        #     for mouse in self.mouselist:
        #         self.s.send(mouse)
        #         time.sleep(0.1)

                
        #     self.s.send('CountDone')

        #     if self.ui.cl_enable.checkState() == 2:
        #         time.sleep(0.1)
        #         self.s.send('cl')
        #     elif self.ui.pul_enable.checkState() == 2:
        #         time.sleep(0.1)
        #         self.s.send('ol')
        #         time.sleep(0.1)
        #         self.s.send(str(self.ui.hi.value()))
        #         time.sleep(0.1)
        #         self.s.send(str(self.ui.lo.value()))
        #         time.sleep(0.1)
        #         self.s.send(str(self.ui.pulsedur.value()))
        #     else:
        #         time.sleep(0.1)
        #         self.s.send('nn')

    @pyqtSlot()
    def endProtocol(self):

        self.end_countdown()

        if self.protocols['option_ol'].isChecked():
            self.end_pcountdown()
        elif self.protocols['option_cl'].isChecked():
            self.end_cl()
        elif self.protocols['option_remdep'].isChecked():
            self.end_dep()
        elif self.protocols['option_nremdep'].isChecked():
            self.end_dep()


    # def end_cl():


    def setupPlots(self):
     
        self.mice_onPlot = {}
        self.plotObjs = {}
        for m_idx in range(len(self.mouselist)):
            ID = self.mouselist[m_idx]
            pos = m_idx + 1
            m_num = 'm' + str(pos)
            try:
                params = load_params(self.remtxt_dir, ID + '_rem.txt')
            except IOError:
                print('REM txt does not exist for the mouse ' + ID +'. Continuing with default values...')
                params = {}
            except NameError:
                print('No threshold found. Continuing...')
                params = {}

            self.mice_onPlot[m_num] = mouse_plotObj(ID, pos, params)

            self.plotObjs[m_num] = [self.ui.graphicsView.addPlot(title = ID + ' Delta Threshold ', row = 1, col = m_idx+1)]
            self.plotObjs[m_num].append(self.ui.graphicsView.addPlot(title = 'Theta/Delta Threshold', row = 2, col = m_idx+1))
            self.plotObjs[m_num].append(self.ui.graphicsView.addPlot(title = 'Mu Power Threshold', row = 3, col = m_idx+1))
            self.plotObjs[m_num].append(self.ui.graphicsView.addPlot(title = 'Raw EEG trace', row = 4, col = m_idx+1))
            self.plotObjs[m_num].append(self.ui.graphicsView.addPlot(title = 'EEG Spectrogram', row = 5, col = m_idx+1))

            raw_plot = self.plotObjs[m_num][-2]
            raw_plot.setXRange(0,5000)
            raw_plot.setYRange(-3000,3000)

            spec_plot = self.plotObjs[m_num][-1]
            spec_plot.clear()
            spec_plot.addItem(self.mice_onPlot[m_num].image_fft)
            ax = spec_plot.getAxis(name='left')
            ax.setTicks([[(0, '0'), (5, '5'), (10, '10'), (15, '15'), (20, '20')]])
            spec_plot.setYRange(0, 20)

            for plot in self.plotObjs[m_num]:
                plot.setMouseEnabled(x = False)

        QTimer.singleShot(2000, lambda: self.beginPlots())  

    def beginPlots(self):

        try:
            self.folderlist = glob.glob(self.buf_dir + '/*')
            self.datdir = max(self.folderlist, key=os.path.getctime)
        
        except:
            self.error_dialog.setText("Buffer file cannot be found. Load a proper setting for ploting.")
            self.error_dialog.show()
            return

        self.updater_thread = QThread(self)
        self.data_getter = worker_buffer(self.datdir, self.mice_onPlot, switch = 1)
        self.data_getter.moveToThread(self.updater_thread)
        self.data_getter.signal_new5sec.connect(self.update_plots)
        self.data_getter.signal_EEGraw.connect(self.update_EEGraw)
        self.updater_thread.started.connect(self.data_getter.run_it)
        self.updater_thread.start()
        self.plotter_on = True
        
    def endPlots(self):

        if self.plotter_on:
            self.plotter_on = False
            self.data_getter.switch = 0
            self.data_getter.fid.close()
            self.data_getter.tid.close()
            self.updater_thread.quit()
            self.updater_thread.wait()

    @pyqtSlot(list, str)
    def update_EEGraw(self, buf, m_idx):
        self.mice_onPlot[m_idx].rawtrace += buf
        self.mice_onPlot[m_idx].rawtrace = self.mice_onPlot[m_idx].rawtrace[-5000:]
        self.plotObjs[m_idx][3].clear()
        self.plotObjs[m_idx][3].plot(self.mice_onPlot[m_idx].rawtrace)

    def update_plots(self, mouseObj, m_idx): #mousename, data_eeg, data_emg):

        for plots in self.plotObjs[m_idx][0:3] + [self.plotObjs[m_idx][4]]:
            plots.clear()

        self.plotObjs[m_idx][0].plot(mouseObj.delta_h)
        self.plotObjs[m_idx][0].plot(mouseObj.thr_deltap, pen = pg.mkPen('r'))

        self.plotObjs[m_idx][1].plot(mouseObj.th_delta_h)
        self.plotObjs[m_idx][1].plot(mouseObj.thr_th_delta1p, pen = pg.mkPen('r'))
        self.plotObjs[m_idx][1].plot(mouseObj.thr_th_delta2p, pen = pg.mkPen('b'))
        self.plotObjs[m_idx][1].plot(mouseObj.rem_h, pen = pg.mkPen('g'))

        self.plotObjs[m_idx][2].plot(mouseObj.mu_h)
        self.plotObjs[m_idx][2].plot(mouseObj.thr_mup, pen = pg.mkPen('r'))

        x = pg.makeARGB(mouseObj.spectro_bufE, levels = [0, mouseObj.thr_delta], lut = self.lut)[0]
        y = pg.makeARGB(mouseObj.spectro_bufM, levels = [0, mouseObj.thr_delta], lut = self.lut)[0]

        self.plotObjs[m_idx][4].addItem(mouseObj.image_fft)
        mouseObj.image_fft.setImage(x)





    @pyqtSlot()
    def start_clicked(self):
        if not self.start_on and not self.preview_on:
            if self.ard_on or self.rpi_on:
                self.mouselist, mouselist_empty, self.places = self.create_mouselist()
                if mouselist_empty:
                    self.error_dialog.setText("There are no mice selected")
                    self.error_dialog.show() 
                    return

                self.start_on = True
                self.disable_input(True)
                self.disable_comment(False)
                self.setupNotes()
                self.setupProtocol()
                self.start_videoRec()
                self.setupPlots()
                self.controls['startbutton'].setStyleSheet("background-color: red")

            else:
                self.error_dialog.setText("You must connect the controller first!")
                self.error_dialog.show()


    @pyqtSlot()
    def stop_clicked(self):

        if self.start_on and not self.preview_on:
            self.start_on = False
            self.graphicsView.clear()
            self.disable_input(False)
            self.disable_comment(True)
            self.endNotes()
            self.endProtocol()
            self.end_videoRec()
            self.endPlots()
            self.commentItems['commentHist'].clear()
            self.commentItems['commentHist'].appendPlainText("Comment history:")
            self.ui.startbutton.setStyleSheet(self.ui.stopbutton.styleSheet())

            for filename in os.listdir('.'):
                if self.todate_full in filename:
                    shutil.move(os.getcwd() + "\\" + filename, self.datdir + "\\" + filename)
                if "cam" in filename:
                    shutil.move(os.getcwd() + "\\" + filename, self.datdir + "\\" + filename)



    # @pyqtSlot()
    # def pulon_clicked(self):

    # @pyqtSlot()
    # def puloff_clicked(self):

    def disable_comment(self, disable):

        self.commentItems['entercomment'].setDisabled(disable)

    @pyqtSlot()
    def submit_comment(self):
        # Writing comment to the txt file
        self.txt = open(self.todate_full + "_notes.txt", 'a')
        self.txt.write("\r\n//")
        self.txt.write(time.asctime()[11:19] + " ")
        self.txt.write(self.commentItems['commentbox'].toPlainText())
        self.txt.close()

        # Writing comment to the history
        current_txt = self.commentItems['commentHist'].toPlainText()
        new_txt = self.commentItems['commentbox'].toPlainText()
        self.commentItems['commentHist'].appendPlainText("\r\n" + time.asctime()[11:19] + " " + new_txt)
        self.commentItems['commentbox'].clear()

    def closeEvent(self, *args, **kwargs):
        super(QtGui.QMainWindow, self).closeEvent(*args, **kwargs)
        self.stop_clicked()
        self.cams_disconnect()
        self.arduino_disconnect()
        



if __name__ == "__main__":

    # Create the QT application
    app = QtWidgets.QApplication(sys.argv)

    # Create the main window
    win = main()

    # Show window
    win.show()

    # Disable window resizing
    win.setFixedSize(win.size())

    # Start QT application
    sys.exit(app.exec_())


















